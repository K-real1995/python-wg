1. Известно, что процессор работает с числами в двоичном представлении. Четные числа в таком представлении всегда 
заканчиваются на 0. Будет иметь смысл следующее решение:

def is_even(num):
   return num & 1 == 0
Что с эффективностью? Неизвестно, сколько операций потребуется процессору для того, чтобы вернуть остаток от деления 
числа на 2, однако для совершения операции И ему потребуется всего один такт.

Подтвердим это замерами на массиве из 10000000 чисел:

%: 2.7199012920000003s
&: 2.36535246s
Делаем вывод, что при использовании оператора & скорость выполнения выше, хоть и ненамного.

2. Первый класс представляет собой простую реализацию массива FIFO без возможности перезаписывать существующие данные. 
Попытка записать данные в переполненный или прочитать данные из пустого буфера вызовет ошибку. В качестве данных 
буфера могут выступать любые элементы.

Второй класс представляет собой кольцевой буфер с возможностью перезаписи существующих данных. При инициализации 
создается массив размера capacity из None элементов. Это значит, что впоследствии мы не сможем использовать None 
в качестве элемента буфера. Попытка прочитать данные из пустого буфера вызовет ошибку.

3. Python, как и многие другие языки высокого уровня, предоставляет возможность сортировки "из коробки" с помощью sorted(). 
В настоящее время стандартным алгоритмом сортировки в Python является Timsort. Основная идея алгоритма в том, что 
сортируемые массивы данных, как правило, содержат упорядоченные подмассивы. Потому, на таких данных Timsort работает 
намного быстрее других алгоритмов сортировки.

Основная идея данного решения в том, что, как правило, все необходимые функции уже встроены или представлены 
в стандартных библиотеках языка. Как правило, эти функции протестированы и оптимизированы разработчиками и будут 
работать стабильнее и быстрее, чем ваша собственная реализация. Для сравнения мы используем встроенную в Python функцию 
сортировки и нашу собственную реализацию Quicksort на массиве из 10000 чисел.

Результаты замеров:

quicksort: 0.024071323999999998s
sorted: 0.002125191999999991s
При повторных замерах мы видим разницу во времени выполнения в 10-20 раз. Стоит отметить, что встроенный алгоритм Timsort реализован на языке C, что также играет немаловажную роль в скорости его выполнения.

Основным недостатком Timsort является сложность его реализации, особенно в сравнении с Quicksort. Достоинствами является его возможность предсказуемо работать за O(nlog2n), независимо от структуры входного массива, и скорость выполнения на массивах, близких к отсортированным, что делает его хорошим выбором при работе с реальными данными.